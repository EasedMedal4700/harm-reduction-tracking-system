// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'reflection_controller.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$ReflectionState {

 Reflection get reflection; Set<String> get selectedIds; bool get showForm; bool get isSaving; String get entryId; double get effectiveness; double get sleepHours; String get sleepQuality; String get nextDayMood; String get energyLevel; String get sideEffects; double get postUseCraving; String get copingStrategies; double get copingEffectiveness; double get overallSatisfaction; String get notes; List<String> get selectedReflections; DateTime get date; int get hour; int get minute;
/// Create a copy of ReflectionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReflectionStateCopyWith<ReflectionState> get copyWith => _$ReflectionStateCopyWithImpl<ReflectionState>(this as ReflectionState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReflectionState&&(identical(other.reflection, reflection) || other.reflection == reflection)&&const DeepCollectionEquality().equals(other.selectedIds, selectedIds)&&(identical(other.showForm, showForm) || other.showForm == showForm)&&(identical(other.isSaving, isSaving) || other.isSaving == isSaving)&&(identical(other.entryId, entryId) || other.entryId == entryId)&&(identical(other.effectiveness, effectiveness) || other.effectiveness == effectiveness)&&(identical(other.sleepHours, sleepHours) || other.sleepHours == sleepHours)&&(identical(other.sleepQuality, sleepQuality) || other.sleepQuality == sleepQuality)&&(identical(other.nextDayMood, nextDayMood) || other.nextDayMood == nextDayMood)&&(identical(other.energyLevel, energyLevel) || other.energyLevel == energyLevel)&&(identical(other.sideEffects, sideEffects) || other.sideEffects == sideEffects)&&(identical(other.postUseCraving, postUseCraving) || other.postUseCraving == postUseCraving)&&(identical(other.copingStrategies, copingStrategies) || other.copingStrategies == copingStrategies)&&(identical(other.copingEffectiveness, copingEffectiveness) || other.copingEffectiveness == copingEffectiveness)&&(identical(other.overallSatisfaction, overallSatisfaction) || other.overallSatisfaction == overallSatisfaction)&&(identical(other.notes, notes) || other.notes == notes)&&const DeepCollectionEquality().equals(other.selectedReflections, selectedReflections)&&(identical(other.date, date) || other.date == date)&&(identical(other.hour, hour) || other.hour == hour)&&(identical(other.minute, minute) || other.minute == minute));
}


@override
int get hashCode => Object.hashAll([runtimeType,reflection,const DeepCollectionEquality().hash(selectedIds),showForm,isSaving,entryId,effectiveness,sleepHours,sleepQuality,nextDayMood,energyLevel,sideEffects,postUseCraving,copingStrategies,copingEffectiveness,overallSatisfaction,notes,const DeepCollectionEquality().hash(selectedReflections),date,hour,minute]);

@override
String toString() {
  return 'ReflectionState(reflection: $reflection, selectedIds: $selectedIds, showForm: $showForm, isSaving: $isSaving, entryId: $entryId, effectiveness: $effectiveness, sleepHours: $sleepHours, sleepQuality: $sleepQuality, nextDayMood: $nextDayMood, energyLevel: $energyLevel, sideEffects: $sideEffects, postUseCraving: $postUseCraving, copingStrategies: $copingStrategies, copingEffectiveness: $copingEffectiveness, overallSatisfaction: $overallSatisfaction, notes: $notes, selectedReflections: $selectedReflections, date: $date, hour: $hour, minute: $minute)';
}


}

/// @nodoc
abstract mixin class $ReflectionStateCopyWith<$Res>  {
  factory $ReflectionStateCopyWith(ReflectionState value, $Res Function(ReflectionState) _then) = _$ReflectionStateCopyWithImpl;
@useResult
$Res call({
 Reflection reflection, Set<String> selectedIds, bool showForm, bool isSaving, String entryId, double effectiveness, double sleepHours, String sleepQuality, String nextDayMood, String energyLevel, String sideEffects, double postUseCraving, String copingStrategies, double copingEffectiveness, double overallSatisfaction, String notes, List<String> selectedReflections, DateTime date, int hour, int minute
});




}
/// @nodoc
class _$ReflectionStateCopyWithImpl<$Res>
    implements $ReflectionStateCopyWith<$Res> {
  _$ReflectionStateCopyWithImpl(this._self, this._then);

  final ReflectionState _self;
  final $Res Function(ReflectionState) _then;

/// Create a copy of ReflectionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? reflection = null,Object? selectedIds = null,Object? showForm = null,Object? isSaving = null,Object? entryId = null,Object? effectiveness = null,Object? sleepHours = null,Object? sleepQuality = null,Object? nextDayMood = null,Object? energyLevel = null,Object? sideEffects = null,Object? postUseCraving = null,Object? copingStrategies = null,Object? copingEffectiveness = null,Object? overallSatisfaction = null,Object? notes = null,Object? selectedReflections = null,Object? date = null,Object? hour = null,Object? minute = null,}) {
  return _then(_self.copyWith(
reflection: null == reflection ? _self.reflection : reflection // ignore: cast_nullable_to_non_nullable
as Reflection,selectedIds: null == selectedIds ? _self.selectedIds : selectedIds // ignore: cast_nullable_to_non_nullable
as Set<String>,showForm: null == showForm ? _self.showForm : showForm // ignore: cast_nullable_to_non_nullable
as bool,isSaving: null == isSaving ? _self.isSaving : isSaving // ignore: cast_nullable_to_non_nullable
as bool,entryId: null == entryId ? _self.entryId : entryId // ignore: cast_nullable_to_non_nullable
as String,effectiveness: null == effectiveness ? _self.effectiveness : effectiveness // ignore: cast_nullable_to_non_nullable
as double,sleepHours: null == sleepHours ? _self.sleepHours : sleepHours // ignore: cast_nullable_to_non_nullable
as double,sleepQuality: null == sleepQuality ? _self.sleepQuality : sleepQuality // ignore: cast_nullable_to_non_nullable
as String,nextDayMood: null == nextDayMood ? _self.nextDayMood : nextDayMood // ignore: cast_nullable_to_non_nullable
as String,energyLevel: null == energyLevel ? _self.energyLevel : energyLevel // ignore: cast_nullable_to_non_nullable
as String,sideEffects: null == sideEffects ? _self.sideEffects : sideEffects // ignore: cast_nullable_to_non_nullable
as String,postUseCraving: null == postUseCraving ? _self.postUseCraving : postUseCraving // ignore: cast_nullable_to_non_nullable
as double,copingStrategies: null == copingStrategies ? _self.copingStrategies : copingStrategies // ignore: cast_nullable_to_non_nullable
as String,copingEffectiveness: null == copingEffectiveness ? _self.copingEffectiveness : copingEffectiveness // ignore: cast_nullable_to_non_nullable
as double,overallSatisfaction: null == overallSatisfaction ? _self.overallSatisfaction : overallSatisfaction // ignore: cast_nullable_to_non_nullable
as double,notes: null == notes ? _self.notes : notes // ignore: cast_nullable_to_non_nullable
as String,selectedReflections: null == selectedReflections ? _self.selectedReflections : selectedReflections // ignore: cast_nullable_to_non_nullable
as List<String>,date: null == date ? _self.date : date // ignore: cast_nullable_to_non_nullable
as DateTime,hour: null == hour ? _self.hour : hour // ignore: cast_nullable_to_non_nullable
as int,minute: null == minute ? _self.minute : minute // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// Adds pattern-matching-related methods to [ReflectionState].
extension ReflectionStatePatterns on ReflectionState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _ReflectionState value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _ReflectionState() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _ReflectionState value)  $default,){
final _that = this;
switch (_that) {
case _ReflectionState():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _ReflectionState value)?  $default,){
final _that = this;
switch (_that) {
case _ReflectionState() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( Reflection reflection,  Set<String> selectedIds,  bool showForm,  bool isSaving,  String entryId,  double effectiveness,  double sleepHours,  String sleepQuality,  String nextDayMood,  String energyLevel,  String sideEffects,  double postUseCraving,  String copingStrategies,  double copingEffectiveness,  double overallSatisfaction,  String notes,  List<String> selectedReflections,  DateTime date,  int hour,  int minute)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _ReflectionState() when $default != null:
return $default(_that.reflection,_that.selectedIds,_that.showForm,_that.isSaving,_that.entryId,_that.effectiveness,_that.sleepHours,_that.sleepQuality,_that.nextDayMood,_that.energyLevel,_that.sideEffects,_that.postUseCraving,_that.copingStrategies,_that.copingEffectiveness,_that.overallSatisfaction,_that.notes,_that.selectedReflections,_that.date,_that.hour,_that.minute);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( Reflection reflection,  Set<String> selectedIds,  bool showForm,  bool isSaving,  String entryId,  double effectiveness,  double sleepHours,  String sleepQuality,  String nextDayMood,  String energyLevel,  String sideEffects,  double postUseCraving,  String copingStrategies,  double copingEffectiveness,  double overallSatisfaction,  String notes,  List<String> selectedReflections,  DateTime date,  int hour,  int minute)  $default,) {final _that = this;
switch (_that) {
case _ReflectionState():
return $default(_that.reflection,_that.selectedIds,_that.showForm,_that.isSaving,_that.entryId,_that.effectiveness,_that.sleepHours,_that.sleepQuality,_that.nextDayMood,_that.energyLevel,_that.sideEffects,_that.postUseCraving,_that.copingStrategies,_that.copingEffectiveness,_that.overallSatisfaction,_that.notes,_that.selectedReflections,_that.date,_that.hour,_that.minute);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( Reflection reflection,  Set<String> selectedIds,  bool showForm,  bool isSaving,  String entryId,  double effectiveness,  double sleepHours,  String sleepQuality,  String nextDayMood,  String energyLevel,  String sideEffects,  double postUseCraving,  String copingStrategies,  double copingEffectiveness,  double overallSatisfaction,  String notes,  List<String> selectedReflections,  DateTime date,  int hour,  int minute)?  $default,) {final _that = this;
switch (_that) {
case _ReflectionState() when $default != null:
return $default(_that.reflection,_that.selectedIds,_that.showForm,_that.isSaving,_that.entryId,_that.effectiveness,_that.sleepHours,_that.sleepQuality,_that.nextDayMood,_that.energyLevel,_that.sideEffects,_that.postUseCraving,_that.copingStrategies,_that.copingEffectiveness,_that.overallSatisfaction,_that.notes,_that.selectedReflections,_that.date,_that.hour,_that.minute);case _:
  return null;

}
}

}

/// @nodoc


class _ReflectionState implements ReflectionState {
  const _ReflectionState({required this.reflection, final  Set<String> selectedIds = const {}, this.showForm = false, this.isSaving = false, this.entryId = '', this.effectiveness = 0.0, this.sleepHours = 0.0, this.sleepQuality = '', this.nextDayMood = '', this.energyLevel = '', this.sideEffects = '', this.postUseCraving = 0.0, this.copingStrategies = '', this.copingEffectiveness = 0.0, this.overallSatisfaction = 0.0, this.notes = '', final  List<String> selectedReflections = const [], required this.date, required this.hour, required this.minute}): _selectedIds = selectedIds,_selectedReflections = selectedReflections;
  

@override final  Reflection reflection;
 final  Set<String> _selectedIds;
@override@JsonKey() Set<String> get selectedIds {
  if (_selectedIds is EqualUnmodifiableSetView) return _selectedIds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableSetView(_selectedIds);
}

@override@JsonKey() final  bool showForm;
@override@JsonKey() final  bool isSaving;
@override@JsonKey() final  String entryId;
@override@JsonKey() final  double effectiveness;
@override@JsonKey() final  double sleepHours;
@override@JsonKey() final  String sleepQuality;
@override@JsonKey() final  String nextDayMood;
@override@JsonKey() final  String energyLevel;
@override@JsonKey() final  String sideEffects;
@override@JsonKey() final  double postUseCraving;
@override@JsonKey() final  String copingStrategies;
@override@JsonKey() final  double copingEffectiveness;
@override@JsonKey() final  double overallSatisfaction;
@override@JsonKey() final  String notes;
 final  List<String> _selectedReflections;
@override@JsonKey() List<String> get selectedReflections {
  if (_selectedReflections is EqualUnmodifiableListView) return _selectedReflections;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_selectedReflections);
}

@override final  DateTime date;
@override final  int hour;
@override final  int minute;

/// Create a copy of ReflectionState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReflectionStateCopyWith<_ReflectionState> get copyWith => __$ReflectionStateCopyWithImpl<_ReflectionState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReflectionState&&(identical(other.reflection, reflection) || other.reflection == reflection)&&const DeepCollectionEquality().equals(other._selectedIds, _selectedIds)&&(identical(other.showForm, showForm) || other.showForm == showForm)&&(identical(other.isSaving, isSaving) || other.isSaving == isSaving)&&(identical(other.entryId, entryId) || other.entryId == entryId)&&(identical(other.effectiveness, effectiveness) || other.effectiveness == effectiveness)&&(identical(other.sleepHours, sleepHours) || other.sleepHours == sleepHours)&&(identical(other.sleepQuality, sleepQuality) || other.sleepQuality == sleepQuality)&&(identical(other.nextDayMood, nextDayMood) || other.nextDayMood == nextDayMood)&&(identical(other.energyLevel, energyLevel) || other.energyLevel == energyLevel)&&(identical(other.sideEffects, sideEffects) || other.sideEffects == sideEffects)&&(identical(other.postUseCraving, postUseCraving) || other.postUseCraving == postUseCraving)&&(identical(other.copingStrategies, copingStrategies) || other.copingStrategies == copingStrategies)&&(identical(other.copingEffectiveness, copingEffectiveness) || other.copingEffectiveness == copingEffectiveness)&&(identical(other.overallSatisfaction, overallSatisfaction) || other.overallSatisfaction == overallSatisfaction)&&(identical(other.notes, notes) || other.notes == notes)&&const DeepCollectionEquality().equals(other._selectedReflections, _selectedReflections)&&(identical(other.date, date) || other.date == date)&&(identical(other.hour, hour) || other.hour == hour)&&(identical(other.minute, minute) || other.minute == minute));
}


@override
int get hashCode => Object.hashAll([runtimeType,reflection,const DeepCollectionEquality().hash(_selectedIds),showForm,isSaving,entryId,effectiveness,sleepHours,sleepQuality,nextDayMood,energyLevel,sideEffects,postUseCraving,copingStrategies,copingEffectiveness,overallSatisfaction,notes,const DeepCollectionEquality().hash(_selectedReflections),date,hour,minute]);

@override
String toString() {
  return 'ReflectionState(reflection: $reflection, selectedIds: $selectedIds, showForm: $showForm, isSaving: $isSaving, entryId: $entryId, effectiveness: $effectiveness, sleepHours: $sleepHours, sleepQuality: $sleepQuality, nextDayMood: $nextDayMood, energyLevel: $energyLevel, sideEffects: $sideEffects, postUseCraving: $postUseCraving, copingStrategies: $copingStrategies, copingEffectiveness: $copingEffectiveness, overallSatisfaction: $overallSatisfaction, notes: $notes, selectedReflections: $selectedReflections, date: $date, hour: $hour, minute: $minute)';
}


}

/// @nodoc
abstract mixin class _$ReflectionStateCopyWith<$Res> implements $ReflectionStateCopyWith<$Res> {
  factory _$ReflectionStateCopyWith(_ReflectionState value, $Res Function(_ReflectionState) _then) = __$ReflectionStateCopyWithImpl;
@override @useResult
$Res call({
 Reflection reflection, Set<String> selectedIds, bool showForm, bool isSaving, String entryId, double effectiveness, double sleepHours, String sleepQuality, String nextDayMood, String energyLevel, String sideEffects, double postUseCraving, String copingStrategies, double copingEffectiveness, double overallSatisfaction, String notes, List<String> selectedReflections, DateTime date, int hour, int minute
});




}
/// @nodoc
class __$ReflectionStateCopyWithImpl<$Res>
    implements _$ReflectionStateCopyWith<$Res> {
  __$ReflectionStateCopyWithImpl(this._self, this._then);

  final _ReflectionState _self;
  final $Res Function(_ReflectionState) _then;

/// Create a copy of ReflectionState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? reflection = null,Object? selectedIds = null,Object? showForm = null,Object? isSaving = null,Object? entryId = null,Object? effectiveness = null,Object? sleepHours = null,Object? sleepQuality = null,Object? nextDayMood = null,Object? energyLevel = null,Object? sideEffects = null,Object? postUseCraving = null,Object? copingStrategies = null,Object? copingEffectiveness = null,Object? overallSatisfaction = null,Object? notes = null,Object? selectedReflections = null,Object? date = null,Object? hour = null,Object? minute = null,}) {
  return _then(_ReflectionState(
reflection: null == reflection ? _self.reflection : reflection // ignore: cast_nullable_to_non_nullable
as Reflection,selectedIds: null == selectedIds ? _self._selectedIds : selectedIds // ignore: cast_nullable_to_non_nullable
as Set<String>,showForm: null == showForm ? _self.showForm : showForm // ignore: cast_nullable_to_non_nullable
as bool,isSaving: null == isSaving ? _self.isSaving : isSaving // ignore: cast_nullable_to_non_nullable
as bool,entryId: null == entryId ? _self.entryId : entryId // ignore: cast_nullable_to_non_nullable
as String,effectiveness: null == effectiveness ? _self.effectiveness : effectiveness // ignore: cast_nullable_to_non_nullable
as double,sleepHours: null == sleepHours ? _self.sleepHours : sleepHours // ignore: cast_nullable_to_non_nullable
as double,sleepQuality: null == sleepQuality ? _self.sleepQuality : sleepQuality // ignore: cast_nullable_to_non_nullable
as String,nextDayMood: null == nextDayMood ? _self.nextDayMood : nextDayMood // ignore: cast_nullable_to_non_nullable
as String,energyLevel: null == energyLevel ? _self.energyLevel : energyLevel // ignore: cast_nullable_to_non_nullable
as String,sideEffects: null == sideEffects ? _self.sideEffects : sideEffects // ignore: cast_nullable_to_non_nullable
as String,postUseCraving: null == postUseCraving ? _self.postUseCraving : postUseCraving // ignore: cast_nullable_to_non_nullable
as double,copingStrategies: null == copingStrategies ? _self.copingStrategies : copingStrategies // ignore: cast_nullable_to_non_nullable
as String,copingEffectiveness: null == copingEffectiveness ? _self.copingEffectiveness : copingEffectiveness // ignore: cast_nullable_to_non_nullable
as double,overallSatisfaction: null == overallSatisfaction ? _self.overallSatisfaction : overallSatisfaction // ignore: cast_nullable_to_non_nullable
as double,notes: null == notes ? _self.notes : notes // ignore: cast_nullable_to_non_nullable
as String,selectedReflections: null == selectedReflections ? _self._selectedReflections : selectedReflections // ignore: cast_nullable_to_non_nullable
as List<String>,date: null == date ? _self.date : date // ignore: cast_nullable_to_non_nullable
as DateTime,hour: null == hour ? _self.hour : hour // ignore: cast_nullable_to_non_nullable
as int,minute: null == minute ? _self.minute : minute // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on
